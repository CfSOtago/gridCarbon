---
params:
  subtitle: ""
  title: ""
  authors: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
  bookdown::word_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    fig_width: 5
always_allow_html: yes
bibliography: '`r paste0(here::here(), "/bibliography.bib")`'
---

```{r knitrSetup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # by default turn off code echo
```


```{r codeSetup, include=FALSE}
# Set start time ----
startTime <- proc.time()
# Local parameters ----
b2Kb <- 1024 #http://whatsabyte.com/P1/byteconverter.htm
b2Mb <- 1048576
plotLoc <- paste0(gcParams$repoLoc, "/docs/plots/") # where to put the plots

library(gridCarbon)
# Packages used in the report ----
rmdLibs <- c("ggplot2", # plots
          "kableExtra", # fancy tables
          "lubridate"
          )
gridCarbon::loadLibraries(rmdLibs)

# Local parameters ----
localParams$lockDownStartDate <- as.Date("2020-03-25")
localParams$lockDownStartDateTime <- lubridate::as_datetime("2020-03-25 23:59:00")
localParams$lockDownEndDate <- lubridate::today()
localParams$lockDownEndDateTime <- lubridate::now()

localParams$recentCutDate <- as.Date("2020-03-01")

localParams$comparePlotCutDate <- as.Date("2020-02-01")

localParams$gamCap <- "Trend line = Generalized additive model (gam) with integrated smoothness estimation"
localParams$lockdownCap <- "\nColoured rectangle = NZ covid lockdown to date"
localParams$weekendCap <- "\nShaded rectangle = weekends"
localParams$noThresh <- "\nNo specified WHO threshold"

localParams$myAlpha <- 0.1
localParams$vLineAlpha <- 0.4
localParams$vLineCol <- "red" # http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
localParams$myTextSize <- 4

# Local functions ----
addLockdownDate <- function(p){
  # assumes p has x = obsDate
  p <- p + annotate("rect", xmin = localParams$lockDownStartDate,
             xmax = localParams$lockDownEndDate, 
             ymin = yMin, ymax = yMax, 
             alpha = localParams$myAlpha, 
             fill = localParams$vLineCol, 
             colour = localParams$vLineCol)
  return(p)
}
addLockdownDateTime <- function(p){
  # assumes p has x = obsDateTime
  p <- p + annotate("rect", xmin = localParams$lockDownStartDateTime,
             xmax = localParams$lockDownEndDateTime, 
             ymin = yMin, ymax = yMax, 
             alpha = localParams$myAlpha, 
             fill = localParams$vLineCol, 
             colour = localParams$vLineCol) 
    
  return(p)
}

# only makes sense to use these for x axis covering March onwards
localParams$weAlpha <- 0.3
localParams$weFill <- "grey50"
addWeekendsDate <- function(p){
  p <- p + annotate("rect", xmin = as.Date("2020-03-07"),
                    xmax = as.Date("2020-03-08"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-14"),
                    xmax = as.Date("2020-03-15"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-21"),
                    xmax = as.Date("2020-03-22"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-28"),
                    xmax = as.Date("2020-03-29"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-04-04"),
                    xmax = as.Date("2020-04-05"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-04-10"),
                    xmax = as.Date("2020-04-13"), # Easter
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  return(p)
}

addWeekendsDateTime <- function(p){
   p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-07 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-08 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-14 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-15 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-21 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-22 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-28 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-29 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-04-04 00:00:00"),
                    xmax = lubridate::as_datetime("2020-04-05 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill) 
  p <- p + annotate("rect", xmin = as_datetime("2020-04-10 00:00:00"),
                    xmax = as_datetime("2020-04-13 23:59:59"), # Easter
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  return(p)
}
```

\newpage

# About

## Citation

```{r citation, child=gcParams$citation}
```

## Report circulation

 * Public – this report is intended for publication following EECA approval.

## Code

All code used to create this report is available from:

 * https://github.com/CfSOtago/gridCarbon

## License {#license}

```{r ccby license, child=gcParams$licenseCCBY}
```

## History

```{r history, child=gcParams$history}
```
 * this [report's edit history](https://github.com/CfSOtago/gridCarbon/commits/master/dataAnalysis/)
 
## Support

```{r generic support, child=gcParams$support}
```
 * The European Union via [SPATIALEC](http://www.energy.soton.ac.uk/tag/spatialec/), a Marie Skłodowska-Curie [Global Fellowship](https://ec.europa.eu/research/mariecurieactions/actions/individual-fellowships_en) based at the University of Otago’s [Centre for Sustainability](http://www.otago.ac.nz/centre-sustainability/staff/otago673896.html) (2017-2019) & the University of Southampton’s [Sustainable Energy Research Group](http://www.otago.ac.nz/centre-sustainability/staff/otago673896.html) (2019-2020) (Anderson);
 * The Uniersity of Otago via a Centre for Sustainability Summer Scholarship (Lotte) and PhD Studentship (Dortans)
 
\newpage

# Introduction

Building on [@khan_analysis_2018], we are interested in GHG emissions from the NZ electricity generation over time. We are especially interested in how this might change during the NZ covid-19 lockdown period (`r localParams$lockDownStart` to `r localParams$lockDownEnd`).

We use two different GHG emissions indicators:

 * % of total generation in a halfhour which was 'low emissions' where this is defined as wind + solar + hydro
 * Calculated CO2e emissions per half hour (not yet implemented)

# Data

## Wholesale generation data

Essentially 'grid' generation from major power stations of various kinds. Data downloaded from `https://www.emi.ea.govt.nz/Wholesale/Datasets/Generation/Generation_MD/` and pre-processed.

```{r testGrid}
h <- head(allGridDT)

kableExtra::kable(h, caption = "Grid gen data (first 6 rows)") %>%
  kable_styling()
```

## Embedded generation data

Essentially 'non-grid' generation from solar photovoltaic and small scale wind which is 'embedded' - i.e. non-grid connected as it is connected 'downstream' of the grid exit points (GXP). Data downloaded from `https://www.emi.ea.govt.nz/Wholesale/Datasets/Metered_data/Embedded_generation` and pre-processed.

```{r headEmbedded}
h <- head(allEmbeddedDT)

kableExtra::kable(h, caption = "Embedded gen data (first 6 rows)") %>%
  kable_styling()
```


```{r testEmbedded}
allEmbeddedDT[, year := lubridate::year(rDate)]
st <- allEmbeddedDT[, .(sumkWh = sum(kWh, na.rm = TRUE),
                        nObs = .N), keyby = .(Flow_Direction, year)]

rt <- data.table::dcast(st, year ~ Flow_Direction,  value.var = c("sumkWh", "nObs"))

kableExtra::kable(rt, caption = "Mean kWh by flow direction") %>%
  kable_styling()
```

Not entirely sure what these codes mean yet. Limited [guidance](https://forum.emi.ea.govt.nz/thread/grid-export-and-embedded-generation-data) available? TBC

> For now embedded generation data is _not_ included in the following analysis.

# Analysis

In this section we analyse the current developments in electricity generation during the Covid-19 level four alert. The level four alert came into effect on March 25 2020 at 11.59pm as part of the fight agianst the novel Covid-19 virus. The minimum lockdown period is four weeks, ending on April 28 This period has wide-spread implications across New Zealand's economy and electriicty consumption, amongst other effects such as everyday life in general.

All non-essential busineeses are closed and staff is asked to work from home. This analysis aims to provide insights on developments in electriicty generation. Essential research questions company this research:

* To what extent has electricty generation shown deviation of 'normal' generation patterns during the level four alert?

* Has the composition of fuel sources supplying electriicty demand in New Zealand changed during the level four alert?

* Has the level four alert impacted greenhouse-gas emissions associated with electriicty generation?

```{r lockdownMethodology, eval=FALSE}

# 1. Select relevant years/months
  # -> What do we want to find out? 
   # Reduction in generation (this requires ex ante/post ante data)
   # Changes in the feed-in of embedded generation
   # Changes in GhG emissions

# 2. Aggregate data by fuel and time
# 3. Link GhG emissions to generation data
# 4. Output of tables/plots embedded in text

```

```{r lockdown1SelectData, include=FALSE}

#Selects Jan and Feb of 2020, 2019, 2018 as we do not have March data yet
selectDT <- allGridDT[month >= 1 & 
                      month <= 4 &
                      year == 2020 |
                        
                      month >= 1 & 
                      month <= 4 &
                      year == 2019 |
                        
                      month >= 1 & 
                      month <= 4 &
                      year == 2018]

#Building means by Fuel_Code, rDateTime, Time_Period, rMonth
shortDT <- selectDT[, . (meankWh = mean(kWh),
                         sumkWh = sum(kWh),
                        nObs = .N), # number of obs - will show you how rare coal is :-)
                    keyby= .(Fuel_Code, rDateTime, Time_Period, rMonth, year)]
#This won't build means by month - it will build them by rDateTime as rMonth is constant for each rDateTime


#This shows us how many obs there are for each Fuel_Code. There might be an easier way to do it?
plotDT <- shortDT[year==2020]
x2 <- by(plotDT$nObs, plotDT$Fuel_Code, sum)
do.call(rbind,as.list(x2))# Clearly hydro dominates
```


```{r nobstable}
#Put this into a table for visualisation
kableExtra::kable(head(x2), col.names = "nObs", caption = "Number of observations by fuel") %>%
                    kable_styling()
```
We extracted electricity generation data from /INSERT DATES/. Table \@ref(tab:nobstable) shows the number of observations for each fuel type for the aforementioned dates. It becomes clear that Hydro was the most used fuel type, followed by Geothermal, Wind, Gas, Coal, and Diesel. 

```{r lockdowncalc}

#Let us try to avoid confusion with kWh and convert it to power MW....
shortDT <- shortDT[, meanMW := (meankWh*2)/1000]
shortDT <- shortDT[, sumMW := (sumkWh*2)/1000]




kableExtra::kable(head(shortDT), caption = "Example summary data") %>%
                    kable_styling()
```
Table \@ref(tab:lockdowncalc) shows exemplary data of our data extraction. In addition, Figure \@ref(fig:plotgeneration1) pictures total generation (this is the sum for each fuel type for all generatinfg plants and all trading periods). Hydro had the highest power output in January and February. Geothermnal was used for base load and an increase in Gas output is viible for the second half of February. Wind intermittently generated while Coal was occasionally integrated. Wood and Diesel did not contribute much in January and February.


```{r plotgeneration1, fig.cap= "Total generation by fuel"}

#Changing order in plot

shortDT$Fuel_Code <- factor(shortDT$Fuel_Code, levels = c("Hydro","Geo",
                                                    "Gas", "Wind", "Coal", "Wood", "Diesel"))

plotDT <- shortDT[year==2020]

legend_title <- "Type of Fuel"
myPlotSum <- ggplot2::ggplot(plotDT, aes(x= rDateTime)) +
  geom_line(aes(y = sumMW, colour = Fuel_Code))+
  geom_smooth(aes(y= sumMW, colour = Fuel_Code))+
  scale_color_manual(legend_title, values = c('Hydro'='blue','Coal'='grey', 'Wind'='green', 'Wood'='brown', 'Diesel'='yellow', 'Gas'='purple', 'Geo'='red'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Time', y='Power (MW)', caption = "Smoothed fit line via gam") 
myPlotSum





```

```{r totalgen, warning=FALSE, message=FALSE}

# Here we attempt to compare total generation over time. Monthly/weekly granularity
# Challenge: Match Monday with Monday and have the same number of days for comparison

#We might need to dcast now...

recastDT <- dcast(shortDT,
           rDateTime + Time_Period + rMonth + year  ~ Fuel_Code, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "sumMW")

# Adding a weekday column
recastDT <- recastDT[, weekdays:= wday(rDateTime, label = TRUE)]
#Adding date column
recastDT[, date := lubridate::as_date(rDateTime)]



recastDT <- recastDT[, totalMW := Coal+Diesel+Gas+Geo+Hydro+Wind+Wood, keyby =.(rDateTime)]


# Let us create a daily mean too
recast_d_meanDT <- recastDT[, .(Hydro = mean(Hydro),
                                Geo = mean(Geo),
                                Gas = mean(Gas),
                                Wind = mean(Wind),
                                Coal = mean(Coal),
                                Wood = mean(Wood),
                                Diesel = mean(Diesel),
                        nObs = .N), # number of obs - will show you how rare coal is :-)
                        keyby= .(date, year,rMonth)]

recast_d_meanDT <- recast_d_meanDT[, totalMW := Coal+Diesel+Gas+Geo+Hydro+Wind+Wood, keyby =.(date)]
recast_d_meanDT <- recast_d_meanDT[, totalMW18_19 := Coal+Diesel+Gas+Geo+Hydro+Wind+Wood, keyby =.(date)]


```

Figure \@ref(fig:fourmonthsplot) shows total generation for the first four months of 2020. A red box indicates the alert level four period.

```{r fourmonths}

plotDT <- recastDT[year==2020]

```

```{r fourmonthsplot, fig.cap="Four months of total generation for 2020"}

#This shows us the selected weeks for January and February
legend_title <- "Month"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= rDateTime )) +
  geom_line(aes(y = totalMW, colour = rMonth))+
  geom_smooth(aes(y=totalMW, colour=NULL))+
  scale_color_manual(legend_title, values = c('Jan'='#A9DFBF','Feb'='#FAD7A0', 'Mar'='#AED6F1', 'Apr' ='#F5B7B1'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Date', y='Power (MW)', caption = "Smoothed fit line via gam") 
  #facet_grid(rMonth ~ .)

yMax <- max(plotDT$totalMW)
yMin <- min(plotDT$totalMW)
addLockdownDateTime(myPlotTot) # adds annotations, needs yMax & yMin to get the box right
```

```{r annualcomparision}

#Now we woild like to compare the first four months of 2020 with the previous years. Challenge lining up Monday with Monday etc. 

                            #2020
plotDT <- recastDT[date >= "2020-01-08"&
                   date <= "2020-01-28"|
                     
                   date >= "2020-02-05"&
                   date <= "2020-02-25"|
                     
                   date >= "2020-03-10"&
                   date <= "2020-03-30"|
                     
                  # date >= "2020-04-01"&
                  # date <= "2020-04-21"|
                     
                          #2019     
                   date >= "2019-01-09"&
                   date <= "2019-01-29"|
                     
                   date >= "2019-02-06"&
                   date <= "2019-02-26"|
                     
                   date >= "2019-03-05"&
                   date <= "2019-03-25"|
                     
                  # date >= "2019-04-03"&
                  # date <= "2019-04-23"| 
                     
                          #2018
                   date >= "2018-01-10"&
                   date <= "2018-01-30"|
                     
                   date >= "2018-02-07"&
                   date <= "2018-02-27"|
                     
                   date >= "2018-03-06"&
                   date <= "2018-03-26"]
                     
                  # date >= "2018-04-04"&
                  # date <= "2018-04-24"]

# Remember that we do not have March and April data for 2020 yet so we have to leave these dates out for now 

# Applying the same overlaying method on three years now...

select <- plotDT[year==2020]

data1 <- data.table(`2020`=numeric())
data1 <-data1[, .(`2020` = ifelse(plotDT$year == "2020" , plotDT$totalMW, NA ))]
data1 <-data1[!is.na(data1$`2020`)]

data2 <- data.table(`2019`=numeric())
data2 <-data2[, .(`2019` = ifelse(plotDT$year == "2019" , plotDT$totalMW, NA ))]
data2 <-data2[!is.na(data2$`2019`)]

data3 <- data.table(`2018`=numeric())
data3 <-data3[, .(`2018` = ifelse(plotDT$year == "2018" , plotDT$totalMW, NA ))]
data3 <-data3[!is.na(data3$`2018`)]

data1 <- data1[, `2019` := data2$`2019`]
data1 <- data1[, `2018` := data3$`2018`]
data1 <- data1[, ID := .I]
data1 <- data1[, date := select$date]
data1 <- data1[, dateTime := select$rDateTime]
data1 <- data1[, rMonth := select$rMonth]

```

In order to provide information on how generation changed over time it is helpful to compare it with previous years. Twenty matching weekdays were extracted for January to March for 2020, 2019, and 2018. We would like to make sure that the weekdays really 'match up'. Figure \@ref(fig:checkplot) shows twenty days of extracted data for the three years for March We see that the weekdays match up.

```{r checkplot, fig.cap="Twenty days of March for 2020, 2019, and 2018"}

#Do the weekdays really match up?

plotDT <- data1[date >= "2020-03-10"&
                   date <= "2020-03-30"]

legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= dateTime)) +
  #geom_smooth(aes(y=`2020`, colour = "2020"))+
  #geom_smooth(aes(y=`2019`, colour = "2019"))+
  #geom_smooth(aes(y=`2018`, colour = "2018"))+
  geom_line(aes(y=`2020`, colour = "2020"))+
   geom_line(aes(y=`2019`, colour = "2019"))+ 
   geom_line(aes(y=`2018`, colour = "2018"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB',`2019`='#229954', `2018`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for March', y='Power (MW)')+
  scale_x_datetime(date_breaks = '3 days',
               minor_breaks = 'day',
              # date_labels = '%b %a')+
               date_labels  ='%n %a')+
  geom_rect(data = data.frame(rMonth = "Mar"), 
            aes(xmin = as_datetime("2020-03-25 00:15:00"), 
                xmax = as_datetime("2020-03-30 23:45:00"), 
                ymin = -Inf, ymax = Inf), 
            alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)
  #geom_rect(data = data.frame(rMonth = "Apr"), 
   #         aes(xmin = as.datetime("2020-04-01 00:15:00"), 
    #            xmax = as.datetime("2020-04-21 23:45:00"), 
     #           ymin = -Inf, ymax = Inf), 
      #      alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)+
  

myPlotTot

```
Figure \@ref(fig:closeupplot)

```{r closeupplot, fig.cap="Total generation over time for the fourth Saturday in March by year "}

# Does tht timing of demand change too?

plotDT <- data1[date == "2020-03-28"]

legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= dateTime)) +
  #geom_smooth(aes(y=`2020`, colour = "2020"))+
  #geom_smooth(aes(y=`2019`, colour = "2019"))+
  #geom_smooth(aes(y=`2018`, colour = "2018"))+
  geom_line(aes(y=`2020`, colour = "2020"))+
   geom_line(aes(y=`2019`, colour = "2019"))+ 
   geom_line(aes(y=`2018`, colour = "2018"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB',`2019`='#229954', `2018`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Fourth Saturday of March', y='Power (MW)')+
  scale_x_datetime(date_breaks = '1 hour',
               #minor_breaks = 'day',
              # date_labels = '%b %a')+
               date_labels  ='%H')
  #limits = as.Date(c('2020-01-08','2020-01-13')))
  #scale_y_continuous( limits = c(3014,5866))


#yMax <- max(plotDT$totalMW)
#yMin <- min(plotDT$totalMW)
#addLockdownDateTime(myPlotTot) # adds annotations, needs yMax & yMin to get the box right

myPlotTot






```
```{r dmeancomparison}
# How would that look like for daily means for Jan-Apr?


                            #2020
plotDT <- recast_d_meanDT[date >= "2020-01-08"&
                   date <= "2020-01-28"|
                     
                   date >= "2020-02-05"&
                   date <= "2020-02-25"|
                     
                   date >= "2020-03-10"&
                   date <= "2020-03-30"|
                     
                  # date >= "2020-04-01"&
                  # date <= "2020-04-21"|
                     
                          #2019     
                   date >= "2019-01-09"&
                   date <= "2019-01-29"|
                     
                   date >= "2019-02-06"&
                   date <= "2019-02-26"|
                     
                   date >= "2019-03-05"&
                   date <= "2019-03-25"|
                     
                  # date >= "2019-04-03"&
                  # date <= "2019-04-23"| 
                     
                          #2018
                   date >= "2018-01-10"&
                   date <= "2018-01-30"|
                     
                   date >= "2018-02-07"&
                   date <= "2018-02-27"|
                     
                   date >= "2018-03-06"&
                   date <= "2018-03-26"]
                     
                  # date >= "2018-04-04"&
                  # date <= "2018-04-24"]

# Remember that we do not have March and April data for 2020 yet so we have to leave these dates out for now 

# Applying the same overlaying method on three years now...

select <- plotDT[year==2020]

data1 <- data.table(`2020`=numeric())
data1 <-data1[, .(`2020` = ifelse(plotDT$year == "2020" , plotDT$totalMW, NA ))]
data1 <-data1[!is.na(data1$`2020`)]

data2 <- data.table(`2019`=numeric())
data2 <-data2[, .(`2019` = ifelse(plotDT$year == "2019" , plotDT$totalMW, NA ))]
data2 <-data2[!is.na(data2$`2019`)]

data3 <- data.table(`2018`=numeric())
data3 <-data3[, .(`2018` = ifelse(plotDT$year == "2018" , plotDT$totalMW, NA ))]
data3 <-data3[!is.na(data3$`2018`)]

data1 <- data1[, `2019` := data2$`2019`]
data1 <- data1[, `2018` := data3$`2018`]
data1 <- data1[, ID := .I]
data1 <- data1[, date := select$date]
data1 <- data1[, rMonth := select$rMonth]

data1 <- data1[, `2018-2019` := (`2019` + `2018`)/2] #Used for a refernce period
data1 <- data1[, `PerDiff` := (1-(`2020` / `2018-2019`))*100] #Used for a differnece in %

#data1 <- data1[, dateTime := select$rDateTime]

```


```{r dailymeanplot, fig.cap="Daily mean generation by year for March"}


#Do the weekdays really match up?

plotDT <- data1[date >= "2020-03-10"&
                   date <= "2020-03-30"]

legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= date)) +
  geom_line(aes(y=`2020`, colour = "2020"))+
  geom_point(aes(y=`2020`, colour = "2020"))+
   geom_line(aes(y=`2019`, colour = "2019"))+
  geom_point(aes(y=`2019`, colour = "2019"))+
   geom_line(aes(y=`2018`, colour = "2018"))+
  geom_point(aes(y=`2018`, colour = "2018"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB',`2019`='#229954', `2018`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for March', y='Daily mean power (MW)')+
  scale_x_date(date_breaks = '3 days',
               minor_breaks = 'day',
              # date_labels = '%b %a')+
               date_labels  ='%n %a')+
  geom_rect(data = data.frame(rMonth = "Mar"), 
            aes(xmin = as.Date("2020-03-25"), 
                xmax = as.Date("2020-03-30"), 
                ymin = -Inf, ymax = Inf), 
            alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)
  #geom_rect(data = data.frame(rMonth = "Apr"), 
   #         aes(xmin = as.Date("2020-04-01"), 
    #            xmax = as.Date("2020-04-21"), 
     #           ymin = -Inf, ymax = Inf), 
      #      alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)+
  

myPlotTot


```

```{r annualcomparisonplot, fig.cap="Three years with each 20 days of data for January and February so far", include=FALSE, eval=FALSE}

#Do we need this plot? Probably not! Especially not with the misleading smoothed line. Better use either facet grid for each month or plot each month seperately.


#This shows us the selected weeks for January and February
legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(data1, aes(x= dateTime)) +
  geom_smooth(aes(y=`2020`, colour = "2020"))+
  geom_smooth(aes(y=`2019`, colour = "2019"))+
  geom_smooth(aes(y=`2018`, colour = "2018"))+
  #geom_line(aes(y=`2020`, colour = "2020"))+
  #geom_line(aes(y=`2019`, colour = "2019"))+ 
  #geom_line(aes(y=`2018`, colour = "2018"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB',`2019`='#229954', `2018`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Day and Month', y='Power (MW)', caption = "Smoothed fit line via gam")
  #scale_x_date(#date_breaks = 'day',
               #minor_breaks = 'day',
               #date_labels = '%b %a')+
               #date_labels  ='%b %n %a')
#limits = as.Date(c('2020-01-08','2020-01-13')))
  #scale_y_continuous( limits = c(3014,5866))


#yMax <- max(plotDT$totalMW)
#yMin <- min(plotDT$totalMW)
#addLockdownDateTime(myPlotTot) # adds annotations, needs yMax & yMin to get the box right

myPlotTot

# date_labels = '%b %d\n%a')+

```

```{r dailymeanplot2}

plotDT <- data1


legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= date)) +
  geom_line(aes(y=`2020`, colour = "2020"))+
  geom_point(aes(y=`2020`, colour = "2020"))+
   geom_line(aes(y=`2018-2019`, colour = "2018-2019"))+
  geom_point(aes(y=`2018-2019`, colour = "2018-2019"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB', `2018-2019`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for January-March', y='Daily mean power (MW)')+
  scale_x_date(date_breaks = '5 days',
               minor_breaks = '1 day',
              # date_labels = '%b %a')+
               date_labels  ='%a')+
  facet_grid(cols = vars(rMonth), scales = "free")+
  geom_rect(data = data.frame(rMonth = "Mar"), 
            aes(xmin = as.Date("2020-03-25"), 
                xmax = as.Date("2020-03-30"), 
                ymin = -Inf, ymax = Inf), 
            alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)
  #geom_rect(data = data.frame(rMonth = "Apr"), 
   #         aes(xmin = as.Date("2020-04-01"), 
    #            xmax = as.Date("2020-04-21"), 
     #           ymin = -Inf, ymax = Inf), 
      #      alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)+
  

myPlotTot

```
```{r dailyperdiffplot, fig.cap="Percentage difference in daily mean between 2018-2019 and 2020"}

plotDT <- data1


# lockdown start: 2020-03-26
# lockdown end: 2020-04-28

#Once we have April data we can add the red box for April. Just reverse the #. This is only possible for the extracted days and not for the whole lockdown period

myPlotTot <- ggplot2::ggplot(plotDT, aes(x= date)) +
  geom_step(aes(y=`PerDiff`))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for January-March', y='Percentage difference')+
  scale_x_date(date_breaks = '5 days',
               minor_breaks = '1 day',
               date_labels  ='%a')+
  facet_grid(cols = vars(rMonth), scales = "free")+
  geom_hline(yintercept=0, linetype="dashed")+
  geom_rect(data = data.frame(rMonth = "Mar"), 
            aes(xmin = as.Date("2020-03-25"), 
                xmax = as.Date("2020-03-30"), 
                ymin = -Inf, ymax = Inf), 
            alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)
  #geom_rect(data = data.frame(rMonth = "Apr"), 
   #         aes(xmin = as.Date("2020-04-01"), 
    #            xmax = as.Date("2020-04-21"), 
     #           ymin = -Inf, ymax = Inf), 
      #      alpha = localParams$myAlpha, fill= localParams$vLineCol, colour = localParams$vLineCol, inherit.aes = FALSE)+
  

myPlotTot


```

```{r whatisnext}

#Next we want to find out what happened on a time_period average for three weeks. Furthermore we would like to find out how the generation composition by fuel source might have changed in the two months. Some fun for tomorrow :)

#Is there variation by fuel type in the months and years? Use facet grid to compare fuel type for the extracted days...
# we need to compare Feb/March 2020 with the mean for Feb/March in previous years, also allowing for different temperatures etc?

```

```{r fuelcomparison}
                            #2020
plotDT <- recastDT[date >= "2020-01-08"&
                   date <= "2020-01-28"|
                     
                   date >= "2020-02-05"&
                   date <= "2020-02-25"|
                     
                   date >= "2020-03-10"&
                   date <= "2020-03-30"|
                     
                  # date >= "2020-04-01"&
                  # date <= "2020-04-21"|
                     
                          #2019     
                   date >= "2019-01-09"&
                   date <= "2019-01-29"|
                     
                   date >= "2019-02-06"&
                   date <= "2019-02-26"|
                     
                   date >= "2019-03-05"&
                   date <= "2019-03-25"|
                     
                  # date >= "2019-04-03"&
                  # date <= "2019-04-23"| 
                     
                          #2018
                   date >= "2018-01-10"&
                   date <= "2018-01-30"|
                     
                   date >= "2018-02-07"&
                   date <= "2018-02-27"|
                     
                   date >= "2018-03-06"&
                   date <= "2018-03-26"]
                     
                  # date >= "2018-04-04"&
                  # date <= "2018-04-24"]

# Remember that we do not have March and April data for 2020 yet so we have to leave these dates out for now 

selectyearDT <- plotDT[year==2020]

hydro20 <- data.table(`H20`=numeric())
hydro20 <-hydro20[, .(`H20` = ifelse(plotDT$year == "2020" , plotDT$Hydro, NA ))]
hydro20 <-hydro20[!is.na(hydro20$`H20`)]

hydro19  <- data.table(`H19`=numeric())
hydro19 <-hydro19[, .(`H19` = ifelse(plotDT$year == "2019" , plotDT$Hydro, NA ))]
hydro19 <-hydro19[!is.na(hydro19$`H19`)]

hydro18  <- data.table(`H18`=numeric())
hydro18 <-hydro18[, .(`H18` = ifelse(plotDT$year == "2018" , plotDT$Hydro, NA ))]
hydro18 <-hydro18[!is.na(hydro18$`H18`)]


geo20 <- data.table(`Ge20`=numeric())
geo20 <-geo20[, .(`Ge20` = ifelse(plotDT$year == "2020" , plotDT$Geo, NA ))]
geo20 <-geo20[!is.na(geo20$`Ge20`)]

geo19 <- data.table(`Ge19`=numeric())
geo19 <-geo19[, .(`Ge19` = ifelse(plotDT$year == "2019" , plotDT$Geo, NA ))]
geo19 <-geo19[!is.na(geo19$`Ge19`)]

geo18 <- data.table(`Ge18`=numeric())
geo18 <-geo18[, .(`Ge18` = ifelse(plotDT$year == "2018" , plotDT$Geo, NA ))]
geo18 <-geo18[!is.na(geo18$`Ge18`)]


gas20 <- data.table(`Ga20`=numeric())
gas20 <-gas20[, .(`Ga20` = ifelse(plotDT$year == "2020" , plotDT$Gas, NA ))]
gas20 <-gas20[!is.na(gas20$`Ga20`)]

gas19 <- data.table(`Ga19`=numeric())
gas19 <-gas19[, .(`Ga19` = ifelse(plotDT$year == "2019" , plotDT$Gas, NA ))]
gas19 <-gas19[!is.na(gas19$`Ga19`)]

gas18 <- data.table(`Ga18`=numeric())
gas18 <-gas18[, .(`Ga18` = ifelse(plotDT$year == "2018" , plotDT$Gas, NA ))]
gas18 <-gas18[!is.na(gas18$`Ga18`)]


wind20 <- data.table(`Wi20`=numeric())
wind20 <-wind20[, .(`Wi20` = ifelse(plotDT$year == "2020" , plotDT$Wind, NA ))]
wind20 <-wind20[!is.na(wind20$`Wi20`)]

wind19 <- data.table(`Wi19`=numeric())
wind19 <-wind19[, .(`Wi19` = ifelse(plotDT$year == "2019" , plotDT$Wind, NA ))]
wind19 <-wind19[!is.na(wind19$`Wi19`)]

wind18 <- data.table(`Wi18`=numeric())
wind18 <-wind18[, .(`Wi18` = ifelse(plotDT$year == "2018" , plotDT$Wind, NA ))]
wind18 <-wind18[!is.na(wind18$`Wi18`)]


coal20 <- data.table(`C20`=numeric())
coal20 <-coal20[, .(`C20` = ifelse(plotDT$year == "2020" , plotDT$Coal, NA ))]
coal20 <-coal20[!is.na(coal20$`C20`)]

coal19 <- data.table(`C19`=numeric())
coal19 <-coal19[, .(`C19` = ifelse(plotDT$year == "2019" , plotDT$Coal, NA ))]
coal19 <-coal19[!is.na(coal19$`C19`)]

coal18 <- data.table(`C18`=numeric())
coal18 <-coal18[, .(`C18` = ifelse(plotDT$year == "2018" , plotDT$Coal, NA ))]
coal18 <-coal18[!is.na(coal18$`C18`)]


wood20 <- data.table(`Wo20`=numeric())
wood20 <-wood20[, .(`Wo20` = ifelse(plotDT$year == "2020" , plotDT$Wood, NA ))]
wood20 <-wood20[!is.na(wood20$`Wo20`)]

wood19 <- data.table(`Wo19`=numeric())
wood19 <-wood19[, .(`Wo19` = ifelse(plotDT$year == "2019" , plotDT$Wood, NA ))]
wood19 <-wood19[!is.na(wood19$`Wo19`)]

wood18 <- data.table(`Wo18`=numeric())
wood18 <-wood18[, .(`Wo18` = ifelse(plotDT$year == "2018" , plotDT$Wood, NA ))]
wood18 <-wood18[!is.na(wood18$`Wo18`)]

diesel20 <- data.table(`D20`=numeric())
diesel20 <-diesel20[, .(`D20` = ifelse(plotDT$year == "2020" , plotDT$Diesel, NA ))]
diesel20 <-diesel20[!is.na(diesel20$`D20`)]

diesel19 <- data.table(`D19`=numeric())
diesel19 <-diesel19[, .(`D19` = ifelse(plotDT$year == "2019" , plotDT$Diesel, NA ))]
diesel19 <-diesel19[!is.na(diesel19$`D19`)]

diesel18 <- data.table(`D18`=numeric())
diesel18 <-diesel18[, .(`D18` = ifelse(plotDT$year == "2018" , plotDT$Diesel, NA ))]
diesel18 <-diesel18[!is.na(diesel18$`D18`)]

# Putting the DTs togetehr


data1 <- data.table()

data1 <- data1[, `hydro20` := hydro20$H20]
data1 <- data1[, `hydro19` := hydro19$`H19`]
data1 <- data1[, `hydro18` := hydro18$`H18`]

data1 <- data1[, `geo20` := geo20$`Ge20`]
data1 <- data1[, `geo19` := geo19$`Ge19`]
data1 <- data1[, `geo18` := geo18$`Ge18`]

data1 <- data1[, `gas20` := gas20$`Ga20`]
data1 <- data1[, `gas19` := gas19$`Ga19`]
data1 <- data1[, `gas18` := gas18$`Ga18`]

data1 <- data1[, `wind20` := wind20$`Wi20`]
data1 <- data1[, `wind19` := wind19$`Wi19`]
data1 <- data1[, `wind18` := wind18$`Wi18`]

data1 <- data1[, `coal20` := coal20$`C20`]
data1 <- data1[, `coal19` := coal19$`C19`]
data1 <- data1[, `coal18` := coal18$`C18`]

data1 <- data1[, `wood20` := wood20$`Wo20`]
data1 <- data1[, `wood19` := wood19$`Wo19`]
data1 <- data1[, `wood18` := wood18$`Wo18`]

data1 <- data1[, `diesel20` := diesel20$`D20`]
data1 <- data1[, `diesel19` := diesel19$`D19`]
data1 <- data1[, `diesel18` := diesel18$`D18`]



data1 <- data1[, date := selectyearDT$date]
data1 <- data1[, dateTime := selectyearDT$rDateTime]
data1 <- data1[, rMonth := selectyearDT$rMonth]

```

```{r hydroplot}

plotDT <- data1[date >= "2020-03-10"&
                   date <= "2020-03-30"]


legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= dateTime)) +
  #geom_smooth(aes(y=`2020`, colour = "2020"))+
  #geom_smooth(aes(y=`2019`, colour = "2019"))+
  #geom_smooth(aes(y=`2018`, colour = "2018"))+
   geom_line(aes(y=`hydro20`, colour = "hydro20"))+
   geom_line(aes(y=`hydro19`, colour = "hydro19"))+ 
   geom_line(aes(y=`hydro18`, colour = "hydro18"))+
  scale_color_manual(legend_title, values = c(`hydro20`='#3498DB',`hydro19`='#229954', `hydro18`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for March', y='Power (MW)')+
 # facet_grid(date ~ .) +
  scale_x_datetime(date_breaks = '3 days',
               minor_breaks = 'day',
              # date_labels = '%b %a')+
               date_labels  ='%n %a')
  #limits = as.Date(c('2020-01-08','2020-01-13')))
  #scale_y_continuous( limits = c(3014,5866))

myPlotTot

#Perhaps it is easier if we gather?



summaryDT = melt(data1, id.vars = c("date", "dateTime", "rMonth"),
                measure.vars = c("hydro20", "hydro19", "hydro18",
                                 "geo20", "geo19", "geo18",
                                 "gas20", "gas19", "gas18",
                                 "wind20", "wind19","wind18",
                                 "coal20", "coal19", "coal18",
                                 "wood20", "wood19", "wood18",
                                 "diesel20","diesel19", "diesel20"))

summaryDT <- summaryDT[, Fuel_Code := NA]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="hydro20"|variable=="hydro19"|variable=="hydro18", "Hydro", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="geo20"|variable=="geo19"|variable=="geo18", "Geo", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="gas20"|variable=="gas19"|variable=="gas18", "Gas", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="wind20"|variable=="wind19"|variable=="wind18", "Wind", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="coal20"|variable=="coal19"|variable=="coal18", "Coal", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="wood20"|variable=="wood19"|variable=="wood18", "Wood", Fuel_Code)]
summaryDT <- summaryDT[, Fuel_Code:= ifelse(variable=="diesel20"|variable=="diesel19"|variable=="diesel18", "Diesel", Fuel_Code)]


summaryDT <- setnames(summaryDT, old=c("variable"), new=c("year"))










plotDT <- summaryDT[Fuel_Code=="Coal"]

legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= dateTime)) +
  #geom_smooth(aes(y=`2020`, colour = "2020"))+
  #geom_smooth(aes(y=`2019`, colour = "2019"))+
  #geom_smooth(aes(y=`2018`, colour = "2018"))+
   geom_line(aes(y=`value`, colour=`year`))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for February', y='Power (MW)')+
 facet_grid(vars(Fuel_Code), vars(rMonth), scales = "free")+
 scale_color_manual(legend_title, values = c("coal20"='#3498DB',"coal19"='#229954', "coal18"='#CA6F1E', labels =c("a", "b", "c")))+
 theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Extracted days for February', y='Power (MW)')+
  scale_x_datetime(date_breaks = '3 days',
               minor_breaks = 'day',
              # date_labels = '%b %a')+
               date_labels  ='%n %a')
  #limits = as.Date(c('2020-01-08','2020-01-13')))
  #scale_y_continuous( limits = c(3014,5866))
myPlotTot


```


# Annexes

## Wholesale generation data ('grid')

```{r skimGrid}
skimr::skim(allGridDT)
```

## Embedded generation data ('nongrid')

```{r skimNonGrid}
skimr::skim(allEmbeddedDT)
```

## Conversion factors


# Runtime

```{r check runtime, include=FALSE}
t <- proc.time() - startTime
elapsed <- t[[3]]
```

Analysis completed in `r round(elapsed,2)` seconds ( `r round(elapsed/60,2)` minutes) using [knitr](https://cran.r-project.org/package=knitr) in [RStudio](http://www.rstudio.com) with `r R.version.string` running on `r R.version$platform`.

# R environment

## R packages used

 * base R [@baseR]
 * bookdown [@bookdown]
 * data.table [@data.table]
 * ggplot2 [@ggplot2]
 * kableExtra [@kableExtra]
 * knitr [@knitr]
 * lubridate [@lubridate]
 * rmarkdown [@rmarkdown]

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
